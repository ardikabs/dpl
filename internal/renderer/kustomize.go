package renderer

import (
	"errors"
	"fmt"
	"path/filepath"

	"github.com/ardikabs/dpl/internal/tools"
	goyaml "gopkg.in/yaml.v3"
	kusttypes "sigs.k8s.io/kustomize/api/types"
)

var _ Renderer = &Kustomize{}

var (
	ErrKustomizeInvalidParams        = errors.New("invalid params type, expecting *KustomizeParams")
	ErrKustomizeFailedAutoGenComment = errors.New("failed to inject auto-generated comment")
)

type KustomizeParams struct {
	KustomizationRef string

	ImageReferenceName string
	ImageName          string
	ImageTag           string
}

type Kustomize struct{}

func (k *Kustomize) Render(workdir string, releaseName string, params interface{}, opts ...RenderOption) error {
	kustomizeParams, ok := params.(*KustomizeParams)
	if !ok {
		return ErrKustomizeInvalidParams
	}

	if kustomizeParams.KustomizationRef == "" {
		kustomizeParams.KustomizationRef = "kustomization.yaml"
	}

	o := &RenderOptions{}
	for _, opt := range opts {
		opt(o)
	}

	log := o.Logger.WithValues(
		"renderer", "kustomize",
		"release", releaseName,
		"params", kustomizeParams,
	)

	// Relatively to the working directory, it will open the Kustomization file
	// Supposed the working directory specified is `/opt/app-manifests/k8s-cluster-dev/myapp`,
	// It will open `/opt/app-manifests/k8s-cluster-dev/myapp/kustomization.yaml`.
	kustFilepath := filepath.Join(workdir, kustomizeParams.KustomizationRef)
	content, kustFile, err := tools.ReadAndOpenFile(kustFilepath)
	if err != nil {
		return err
	}
	defer kustFile.Close()

	var kust kusttypes.Kustomization
	if err := kust.Unmarshal(content); err != nil {
		return err
	}

	log.Info("start to inspect kustomization file",
		"ref", kustomizeParams.ImageReferenceName,
		"image", kustomizeParams.ImageName,
		"tag", kustomizeParams.ImageTag,
		"kustomizeRef", kustomizeParams.KustomizationRef,
	)

	var foundImageSelector bool
	for idx, img := range kust.Images {
		if img.Name == kustomizeParams.ImageReferenceName {
			kust.Images[idx].NewName = kustomizeParams.ImageName
			kust.Images[idx].NewTag = kustomizeParams.ImageTag

			foundImageSelector = true
			log.Info("found image reference")
			break
		}
	}

	if !foundImageSelector {
		log.Info("image reference not found, hence appending image definition")

		kust.Images = append(kust.Images, kusttypes.Image{
			Name:    kustomizeParams.ImageReferenceName,
			NewName: kustomizeParams.ImageName,
			NewTag:  kustomizeParams.ImageTag,
		})
	}

	node := new(goyaml.Node)
	if err := node.Encode(kust); err != nil {
		return err
	}

	if err := kustomizeInjectAutoGeneratedCommentToYAML(kustomizeParams, node); err != nil {
		return err
	}

	enc := goyaml.NewEncoder(kustFile)
	// If custom writer is specified, it will use the custom writer instead of the file writer.
	// This is useful for testing purposes.
	if o.CustomWriter != nil {
		enc = goyaml.NewEncoder(o.CustomWriter)
	}

	enc.SetIndent(2)

	if err := enc.Encode(node); err != nil {
		return err
	}
	return nil
}

func kustomizeInjectAutoGeneratedCommentToYAML(params *KustomizeParams, node *goyaml.Node) error {
	for i := 0; i < len(node.Content); i++ {
		rootNodeValue := node.Content[i].Value

		if rootNodeValue == "images" {
			childNode := node.Content[i+1]

			for _, imageNode := range childNode.Content {
				if imageNode.Kind == goyaml.MappingNode {
					foundImageReference := false
					for j := 0; j < len(imageNode.Content); j += 2 {
						key := imageNode.Content[j].Value
						value := imageNode.Content[j+1].Value

						if key == "name" && value == params.ImageReferenceName {
							foundImageReference = true
							break
						}
					}

					if foundImageReference {
						comment := "Image '%s' is managed by dpl. DO NOT EDIT.\n"
						comment += "Warning! Direct changes might be overwritten in the next deployment lifecycle."

						imageNode.HeadComment = fmt.Sprintf(comment, params.ImageReferenceName)
						break
					}

				}
			}

			return nil
		}
	}

	return ErrKustomizeFailedAutoGenComment
}
